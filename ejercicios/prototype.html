<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prototype</title>
</head>
<body>
    <p><em>Abre la consola</em></p>
    
    <script>
        // Crear un objeto com√∫n y corriente

        const goku = {
            nombre: 'Son Goku'
        }

        goku.saludar = function() {
            console.log(`Hola soy ${this.nombre}`);
        }

        goku.saludar();

        // ---
        const vegeta = {
            nombre: 'Son Vegeta'
        }

        vegeta.saludar = function() {
            console.log(`Hola soy ${this.nombre}`);
        }

        vegeta.saludar();

        // ---

        const radix = {
            nombre: 'Radix',
            objetivo: 'Planeta Tierra üòà'
        }

        radix.saludar = function() {
            console.log(`Hola soy ${this.nombre}`);
        }

        radix.destruir = function() {
            console.log(`El objetivo de ${this.nombre} es destruir el ${this.objetivo}`);
        }
        radix.saludar();
        radix.destruir();

        // Explicaci√≥n: Si queremos crear otro objeto similar, tenemos que repetir el proceso, objeto por objeto y esto es completamente tedioso. La √∫nica ventaja que tenemos es que cada objeto al ser independiente, puede tener diferente estado y comportamiento.

        // Aplicar eficiencia al declarar una funci√≥n que construya el objeto y lo retorne para poder invocarlo

        function Personajes(nombre_personaje) {
            const guerrero = {
                nombre: nombre_personaje
            }
            guerrero.saludar = function() {
                console.log(`Hola mi nombre es ${this.nombre}`);
            }
            return guerrero;
        }

        const kakaroto = Personajes('Kakaroto');
        const veyita = Personajes('Veyita');
        const napa = Personajes('Napa');

        kakaroto.saludar();
        veyita.saludar();
        napa.saludar();

        // Explicaci√≥n: Ahora todos nuestros objetos construidos al invocar la funci√≥n tienen el mismo comportamiento. Sin embargo, la funci√≥n asignada al m√©todo saludar es creada por cada personaje instanciado.

        // Evitar crear la funci√≥n cada vez que se intancia un objeto.
        const MethodsCollection = {
            saludar: function() {
                console.log(`Paisano, soy ${this.nombre}`);
            }
        }

        function Characters(nombre_personaje) {
            const guerrero = {
                nombre: nombre_personaje
            }
            // Punto clave ‚ö†Ô∏è
            guerrero.saludar = MethodsCollection.saludar

            return guerrero;
        }

        const ranma = Characters('Ranma 1/2');
        const kuno = Characters('Kuno Tatehuaki');
        const rioga = Characters('Rioga');

        ranma.saludar();
        kuno.saludar();
        rioga.saludar();

        // Explicaci√≥n: Al guardar la referencia a la funci√≥n y posteriormente asociarla en alguno de los m√©todos de nuestro objeto, nos trae mucha eficiencia de c√≥mputo. Puesto que no se crea la funci√≥n por cada instancia (caso anterior), sino que se hace referencia a la misma localizaci√≥n de memoria.

        // Objet.create()
        // Esta funci√≥n lo que hace es recibir un objeto como par√°metro y retorna un nuevo objeto con las caracter√≠sticas del anterior.

        // Es importante destacar que el objeto devuelto est√° vac√≠o {}, sin embargo las caracter√≠sticas heredadas se encuentran contenidas en la propiedad __proto__ (es decir, se tiene acceso a ellas por herencia prototipal).

        // Esto se hace para generar copias de un objeto y posteriormente extedenderlas con otras caracter√≠sticas.
        function Hero(nombre, categoria){
            const luchador = Object.create(MethodsCollection)
            
            luchador.nombre = nombre

            luchador.categoria = categoria

            // luchador.saludar = function(){
            //     console.log(`Hola que onda üññ, mi nombre es ${this.nombre}`);
            // }

            luchador.ki = function() {
                console.log(`Nivel de Ki aceptado en la categoria ${this.categoria}`);
            }

            return luchador;
        }

        const parka = Hero('La Parka', 'AAA');
        const octagon = Hero('Sr. Octagon', 'AAA');
        const mascarita = Hero('Mascarita Sagrada Jr.', 'Asenso');

        parka.saludar();
        octagon.saludar();
        mascarita.saludar();

        parka.ki();
        octagon.ki();
        mascarita.ki();

        // Explicaci√≥n: Creamos una copia del objeto que contiene todos los m√©todos (funciones) y posteriormente lo extendemos con algunas propiedades. Finalmente lo retornamos para poder interactura con el objeto desde el exterior.

        // Prototype:
        // Los m√©todos del objeto dentro del prototipo (__proto__) del objeto Prototipal
        function Deportista(nombre, tecnica){
            // 2. Creamos un objeto vac√≠o, que internamente en su prototipo tiene declarada la funci√≥n saludar (heredada)
            const atleta = Object.create(Deportista.prototype)

            // 3. Extendemos ese objeto
            atleta.nombre = nombre
            atleta.tecnica = tecnica

            return atleta;
        }

        // 1. Punto clave (a√±adir m√©todos al prototipo del objeto)
        Deportista.prototype.saludar = function() {
            console.log(`Mi nombre es ${this.nombre} y soy un deportista`);
        }

        Deportista.prototype.mostrarTecnica = function() {
            console.log(`${this.nombre} tiene t√©cnica de ${this.tecnica}`);
        }

        const oliver = Deportista('Oliver Atom', 'Tiro con chanfle');
        const tom = Deportista('Tom Izaqui', 'Tiro de escuadra');

        oliver.saludar();
        tom.saludar();

        oliver.mostrarTecnica();
        tom.mostrarTecnica();

        // new es un atajo (az√∫car sint√°ctica) al caso anterior
        // Su funci√≥n es llevar Object.prototype al objeto de forma impl√≠cita, es decir, no tenemos que usar Object.create() ni return del objeto.

        function Pokemon(nombre, habilidad) {
            // 1. No hay necesidad de hacer Object.create (ya que por defecto el objeto es this)
            // 2. Se emplea el objeto this para a√±adir propiedades            
            this.nombre = nombre
            this.habilidad = habilidad
            // 3. No hay necesidad de retornar el objeto this
        }

        // ‚ö†Ô∏è Los prototipos se escriben sin arrow function, ya que el hacerlo cambiariamos por completo el contexto de this, ahora ser√≠a window
        Pokemon.prototype.saludar = function() {
            console.log(`Taraam, mi nombre es ${this.nombre}`);
        }

        Pokemon.prototype.mostrarHabilidad = function() {
            console.log(`${this.nombre} tiene la habilidad de ${this.habilidad}`);
        }

        // 4. La palabra clave new, pasa implicitamente el Pokemon.create(Pokemon.prototype) dentro del objeto prototipal. Tambi√©n retorna implicitamente el objeto this.

        const pikachu = new Pokemon('Pikachu üê§', 'Rayos y centellas');
        const melindron = new Pokemon('M√©lindron', 'Generar polvo');

        pikachu.saludar();
        melindron.saludar();

        pikachu.mostrarHabilidad();
        melindron.mostrarHabilidad();

        // La keyword new crea un nuevo objeto que "hereda" todas las propiedades del prototype de otro objeto. No confundir prototyp con __proto__, este √∫ltimo es s√≥lo una propiedad en cada instancia que apunta al prototipo del que hereda.

        // Como se puede observar, podemos hacer lo mismo sin hacer uso del keyword 'new', sin embargo, este nos facilita muchas cosas.

        // Tambi√©n existen otros keywords como 'class' que nos ayudan a ahorrar muchas l√≠neas de c√≥digo y que √©ste tenga una sintaxis clara. Sin embargo, no hay que perder de vista que s√≥lo es un wrapper a los prototype‚Ä¶

        // Esta es la evoluci√≥n de JS

        var arr1 = [1,2,3,4];var arr2 = Array(1,2,3,4);

    </script>
</body>
</html>